#### Redis源码分析-redisObject
          
> 由于之前看注释版本的源码，所以此分析也是基于Redis2.6版本，之后会分析最新5.x源码

# 定义

```markdown
typedef struct redisObject {

    // 类型
    unsigned type:4;        

    // 不使用(对齐位)
    unsigned notused:2;

    // 编码方式
    unsigned encoding:4;

    // LRU 时间（相对于 server.lruclock）
    unsigned lru:22;

    // 引用计数
    int refcount;

    // 指向对象的值
    void *ptr;

} robj;
```

## type


对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，如下：

```markdown
类型常量	            对象的名称
--------------------------------
REDIS_STRING	    字符串对象
REDIS_LIST	        列表对象
REDIS_HASH	        哈希对象
REDIS_SET	        集合对象
REDIS_ZSET	        有序集合对象
```

`type`命令用于检测一个key的类型信息，可能是如下几种：
```markdown
对象	    对象 type 属性的值	TYPE 命令的输出
-----------------------------------------------
字符串对象	REDIS_STRING	    "string"
列表对象	    REDIS_LIST	        "list"
哈希对象	    REDIS_HASH	        "hash"
集合对象	    REDIS_SET	        "set"
有序集合对象	REDIS_ZSET	        "zset"
```

## ptr

对象的 ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的 encoding 属性决定


## encoding

encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现，取值范围：

```markdown
编码常量	                    编码所对应的底层数据结构
------------------------------------------------------
REDIS_ENCODING_INT	        long 类型的整数
REDIS_ENCODING_EMBSTR	    embstr 编码的简单动态字符串
REDIS_ENCODING_RAW	        简单动态字符串
REDIS_ENCODING_HT	        字典
REDIS_ENCODING_LINKEDLIST	双端链表
REDIS_ENCODING_ZIPLIST	    压缩列表
REDIS_ENCODING_INTSET	    整数集合
REDIS_ENCODING_SKIPLIST	    跳跃表和字典
```

[more](http://redisbook.com/preview/object/object.html)

每种类型的对象都至少使用了两种不同的编码，可选择范围：
```markdown
类型	        编码	                    对象
-----------------------------------------------------------------------------
REDIS_STRING	REDIS_ENCODING_INT	        使用整数值实现的字符串对象。
REDIS_STRING	REDIS_ENCODING_EMBSTR	    使用 embstr 编码的简单动态字符串实现的字符串对象
REDIS_STRING	REDIS_ENCODING_RAW	        使用简单动态字符串实现的字符串对象
REDIS_LIST	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的列表对象
REDIS_LIST	    REDIS_ENCODING_LINKEDLIST	使用双端链表实现的列表对象
REDIS_HASH	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的哈希对象
REDIS_HASH	    REDIS_ENCODING_HT	        使用字典实现的哈希对象
REDIS_SET	    REDIS_ENCODING_INTSET	    使用整数集合实现的集合对象
REDIS_SET	    REDIS_ENCODING_HT	        使用字典实现的集合对象
REDIS_ZSET	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的有序集合对象
REDIS_ZSET	    REDIS_ENCODING_SKIPLIST	    使用跳跃表和字典实现的有序集合对象
```

通过下面一个例子来说明type，debug，encoding，等几个命令的使用区别

![具体例子](./Assets/06/object-encoding.png '')

```markdown
type  返回key的类型
OBJECT ENCODING 返回key的底层encoding
DEBUG OBJECT 返回底层key的包括内容指针位置，引用个数，encoding类型，lru时钟等信息
```


### OBJECT ENCODING 对不同编码的输出

```markdown
对象所使用的底层数据结构	        编码常量	                    OBJECT ENCODING 命令输出
-------------------------------------------------------------------------------------
整数	                        REDIS_ENCODING_INT	        "int"
embstr编码的简单动态字符串（SDS）	REDIS_ENCODING_EMBSTR	    "embstr"
简单动态字符串	                REDIS_ENCODING_RAW	        "raw"
字典	                        REDIS_ENCODING_HT	        "hashtable"
双端链表	                        REDIS_ENCODING_LINKEDLIST	"linkedlist"
压缩列表	                        REDIS_ENCODING_ZIPLIST	    "ziplist"
整数集合	                        REDIS_ENCODING_INTSET	    "intset"
跳跃表和字典	                    REDIS_ENCODING_SKIPLIST	    "skiplist"
```

> 通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 
因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率

- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；


# string对象

![例子](./Assets/06/type-string.png 'string')

如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int

![例子](./Assets/06/string-example.png '')


如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 

![例子](./Assets/06/string-example2.png '')

如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值

embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构，如图：

![例子](./Assets/06/string-example3.png '')

实例

![例子](./Assets/06/string-example4.png '')

> embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：

- embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次（raw是先分配sds，再分配robj）
- 释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数（先释放sds，再释放robj）
- 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势


> int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。

- 对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw
- 对于字符串内容长度超过39字节，embstr结构会转成raw方式存储

string结构简易表示：

![string结构简易表示](./Assets/06/string-simple.png '')

string结构完整表示：

![string结构完整表示](./Assets/06/string-full.png '')


# list对象

> list对象的编码可以是 ziplist 或者 linkedlist


ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素

![例子](./Assets/06/type-list-ziplist.png 'list')


linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素


![例子](./Assets/06/type-list-linklist.png 'list')

> linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 
字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象

