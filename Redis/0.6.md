#### Redis源码分析-redisObject
          
> 由于之前看注释版本的源码，所以此分析也是基于Redis2.6版本，之后会分析最新5.x源码

# 定义

```markdown
typedef struct redisObject {

    // 类型
    unsigned type:4;        

    // 不使用(对齐位)
    unsigned notused:2;

    // 编码方式
    unsigned encoding:4;

    // LRU 时间（相对于 server.lruclock）
    unsigned lru:22;

    // 引用计数
    int refcount;

    // 指向对象的值
    void *ptr;

} robj;
```

## type


对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，如下：

```markdown
类型常量	            对象的名称
--------------------------------
REDIS_STRING	    字符串对象
REDIS_LIST	        列表对象
REDIS_HASH	        哈希对象
REDIS_SET	        集合对象
REDIS_ZSET	        有序集合对象
```

`type`命令用于检测一个key的类型信息，可能是如下几种：
```markdown
对象	    对象 type 属性的值	TYPE 命令的输出
-----------------------------------------------
字符串对象	REDIS_STRING	    "string"
列表对象	    REDIS_LIST	        "list"
哈希对象	    REDIS_HASH	        "hash"
集合对象	    REDIS_SET	        "set"
有序集合对象	REDIS_ZSET	        "zset"
```

## ptr

对象的 ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的 encoding 属性决定


## encoding

encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现，取值范围：

```markdown
编码常量	                    编码所对应的底层数据结构
------------------------------------------------------
REDIS_ENCODING_INT	        long 类型的整数
REDIS_ENCODING_EMBSTR	    embstr 编码的简单动态字符串
REDIS_ENCODING_RAW	        简单动态字符串
REDIS_ENCODING_HT	        字典
REDIS_ENCODING_LINKEDLIST	双端链表
REDIS_ENCODING_ZIPLIST	    压缩列表
REDIS_ENCODING_INTSET	    整数集合
REDIS_ENCODING_SKIPLIST	    跳跃表和字典
```

[more](http://redisbook.com/preview/object/object.html)

每种类型的对象都至少使用了两种不同的编码，可选择范围：
```markdown
类型	        编码	                    对象
-----------------------------------------------------------------------------
REDIS_STRING	REDIS_ENCODING_INT	        使用整数值实现的字符串对象。
REDIS_STRING	REDIS_ENCODING_EMBSTR	    使用 embstr 编码的简单动态字符串实现的字符串对象
REDIS_STRING	REDIS_ENCODING_RAW	        使用简单动态字符串实现的字符串对象
REDIS_LIST	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的列表对象
REDIS_LIST	    REDIS_ENCODING_LINKEDLIST	使用双端链表实现的列表对象
REDIS_HASH	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的哈希对象
REDIS_HASH	    REDIS_ENCODING_HT	        使用字典实现的哈希对象
REDIS_SET	    REDIS_ENCODING_INTSET	    使用整数集合实现的集合对象
REDIS_SET	    REDIS_ENCODING_HT	        使用字典实现的集合对象
REDIS_ZSET	    REDIS_ENCODING_ZIPLIST	    使用压缩列表实现的有序集合对象
REDIS_ZSET	    REDIS_ENCODING_SKIPLIST	    使用跳跃表和字典实现的有序集合对象
```

通过下面一个例子来说明type，debug，encoding，等几个命令的使用区别

![具体例子](./Assets/06/object-encoding.png '')

```markdown
type  返回key的类型
OBJECT ENCODING 返回key的底层encoding
DEBUG OBJECT 返回底层key的包括内容指针位置，引用个数，encoding类型，lru时钟等信息
```


### OBJECT ENCODING 对不同编码的输出

```markdown
对象所使用的底层数据结构	        编码常量	                    OBJECT ENCODING 命令输出
-------------------------------------------------------------------------------------
整数	                        REDIS_ENCODING_INT	        "int"
embstr编码的简单动态字符串（SDS）	REDIS_ENCODING_EMBSTR	    "embstr"
简单动态字符串	                REDIS_ENCODING_RAW	        "raw"
字典	                        REDIS_ENCODING_HT	        "hashtable"
双端链表	                        REDIS_ENCODING_LINKEDLIST	"linkedlist"
压缩列表	                        REDIS_ENCODING_ZIPLIST	    "ziplist"
整数集合	                        REDIS_ENCODING_INTSET	    "intset"
跳跃表和字典	                    REDIS_ENCODING_SKIPLIST	    "skiplist"
```

> 通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 
因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率

- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；


# string对象

![例子](./Assets/06/type-string.png 'string')

如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int

![例子](./Assets/06/string-example.png '')


如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 

![例子](./Assets/06/string-example2.png '')

如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值

embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构，如图：

![例子](./Assets/06/string-example3.png '')

实例

![例子](./Assets/06/string-example4.png '')

> embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：

- embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次（raw是先分配sds，再分配robj）
- 释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数（先释放sds，再释放robj）
- 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势


> int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。
- 对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw
- 对于字符串内容长度超过39字节，embstr结构会转成raw方式存储

string结构简易表示：

![string结构简易表示](./Assets/06/string-simple.png '')

string结构完整表示：

![string结构完整表示](./Assets/06/string-full.png '')


# list对象

> list对象的编码可以是 ziplist 或者 linkedlist

当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码，其他情况使用 linkedlist 编码：
- 列表对象保存的所有字符串元素的长度都小于 64 字节
- 列表对象保存的元素数量小于 512 个



ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素

![例子](./Assets/06/type-list-ziplist.png 'list')


linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素


![例子](./Assets/06/type-list-linklist.png 'list')

> linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 
字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象

# hash对象

哈希对象的编码可以是 ziplist 或者 hashtable

> ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾

- 保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向

执行如下命令，先删除已有的profile，再创建一个hash对象profile
```markdown
redis> del profile
(integer) 1

redis> HSET profile name "Tom"
(integer) 1

redis> HSET profile age 25
(integer) 1

redis> HSET profile career "Programmer"
(integer) 1
```

则存储结果如下：

![例子](./Assets/06/type-hash.png 'hash')

![例子](./Assets/06/type-hash-ziplist.png 'hash')


另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：
- 字典的每个键都是一个字符串对象， 对象中保存了键值对的键
- 字典的每个值都是一个字符串对象， 对象中保存了键值对的值


如果前面 profile 键创建的不是 ziplist 编码的哈希对象， 而是 hashtable 编码的哈希对象， 那么这个哈希对象应该会如下图：

![例子](./Assets/06/type-hash-dict.png 'hash')

当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码，否则使用 hashtable 编码
- 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节
- 哈希对象保存的键值对数量小于 512 个

```markdown

命令	ziplist 编码实现方法	                                                            hashtable 编码的实现方法
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HSET	首先调用 ziplistPush 函数， 将键推入到压缩列表的表尾，                              调用 dictAdd 函数， 将新节点添加到字典里面
        然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾。
        	        
HGET	首先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点，                     调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值。
        然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。
        	
HEXISTS	调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点，                        调用 dictFind 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。
        如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。
        	
HDEL	调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点，                        调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉。
        然后将相应的键节点、 以及键节点旁边的值节点都删除掉。
        
HLEN	调用 ziplistLen 函数， 取得压缩列表包含节点的总数量，                              调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。
        将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量。
        	
HGETALL	遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点）。                    遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值。


```
[更多](http://redisbook.com/preview/object/hash.html)



