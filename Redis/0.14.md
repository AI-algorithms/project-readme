#### Redis-事件驱动
          
> 由于之前看注释版本的源码，所以此分析也是基于Redis2.6版本，之后会分析最新5.x源码

# 可选择的io多路复用：epoll，kqueue，poll，select

从这个引入文件顺序看，优先使用性能高并且支持的io多路复用方案

```markdown
#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
    #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
        #include "ae_kqueue.c"
        #else
        #include "ae_select.c"
        #endif
    #endif
#endif
```

其中主要可以看epoll为例，[更多](https://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html)


# 注册时间

initServer()函数里，创建fd并监听
```markdown
// 关联网络连接事件
    if (server.ipfd > 0 && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
        acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");
    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
        acceptUnixHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.sofd file event.");

```

> acceptTcpHandler、acceptUnixHandler

- acceptTcpHandler 是处理 server.ipfd 可读、可写，tcp socket网络连接的回调函数
- acceptUnixHandler 是处理 server.sofd 可读、可写，unix socket连接的回调函数

当事件可读时候相同的是会调用 accept 系统调用，然后创建一个redis client并初始化之

`main()`函数里的`aeMain(server.el);`用于启动服务器循环，只有`stop`开关没关闭，就一直循环

`aeProcessEvents()`用于处理所有已到达的时间事件和已就绪的文件事件

其中时间事件是用一个链表维护一个事件列表，表示xx时间将要执行xx操作；文件事件是 取出 `eventLoop->events`里可读、可写的fd，挨个执行他的回调函数

