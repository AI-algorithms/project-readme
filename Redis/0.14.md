#### Redis-事件驱动
          
> 由于之前看注释版本的源码，所以此分析也是基于Redis2.6版本，之后会分析最新5.x源码

# 可选择的io多路复用：epoll，kqueue，poll，select

从这个引入文件顺序看，优先使用性能高并且支持的io多路复用方案

```markdown
#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
    #ifdef HAVE_EPOLL
    #include "ae_epoll.c"
    #else
        #ifdef HAVE_KQUEUE
        #include "ae_kqueue.c"
        #else
        #include "ae_select.c"
        #endif
    #endif
#endif
```

其中主要可以看epoll为例，[更多](https://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html)


# 注册时间

initServer()函数里，创建fd并监听
```markdown
// 关联网络连接事件
    if (server.ipfd > 0 && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
        acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");
    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
        acceptUnixHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.sofd file event.");

```

> acceptTcpHandler、acceptUnixHandler

- acceptTcpHandler 是处理 server.ipfd 可读、可写，tcp socket网络连接的回调函数
- acceptUnixHandler 是处理 server.sofd 可读、可写，unix socket连接的回调函数

当事件可读时候相同的是会调用 accept 系统调用，然后创建一个redis client并初始化之

`main()`函数里的`aeMain(server.el);`用于启动服务器循环，只有`stop`开关没关闭，就一直循环

`aeProcessEvents()` 用于处理所有已到达的时间事件和已就绪的文件事件

其中时间事件是用一个链表维护一个事件列表，表示xx时间将要执行xx操作；文件事件是 取出 `eventLoop->events`里可读、可写的fd，挨个执行他的回调函数


文件事件结构
```markdown
typedef struct aeFileEvent {
    // 事件类型掩码，值可以是 AE_READABLE 或 AE_WRITABLE ，或者两者的或
    int mask; /* one of AE_(READABLE|WRITABLE) */
    // 读事件函数
    aeFileProc *rfileProc;
    // 写事件函数
    aeFileProc *wfileProc;
    // 多路复用库的私有数据
    void *clientData;
} aeFileEvent;
```

时间事件结构
```markdown
typedef struct aeTimeEvent {

    // 时间事件的唯一标识符
    long long id; /* time event identifier. */

    // 事件的到达时间
    long when_sec; /* seconds */
    long when_ms; /* milliseconds */

    // 事件处理函数
    aeTimeProc *timeProc;

    // 事件释放函数
    aeEventFinalizerProc *finalizerProc;

    // 多路复用库的私有数据
    void *clientData;

    // 指向下个时间事件结构，形成链表
    struct aeTimeEvent *next;

} aeTimeEvent;
```

时间事件的启动是在 `initServer()`函数里 `aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);`，设置1ms执行1次，具体主体代码在 `serverCron()`函数里

serverCron函数里执行内容包括：
- 修改服务器LRU时间，Unix时间保存在server变量里
- 最大内存使用情况
- 试图执行搜索db的size，并执行1ms的渐进式rehash
- 常规客户端状态检查、超时检查等
- rdb内容保存，aof内容保存

文件事件是在创建了server.ipfd（server.sofd）之后用 `aeCreateFileEvent()` 加入到 `server.el` 里去监听
